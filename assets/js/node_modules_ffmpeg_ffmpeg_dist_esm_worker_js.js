/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@ffmpeg/ffmpeg/dist/esm lazy recursive":
/*!*********************************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/dist/esm/ lazy namespace object ***!
  \*********************************************************************/
/***/ ((module) => {

eval("function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(() => {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = () => ([]);\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./node_modules/@ffmpeg/ffmpeg/dist/esm lazy recursive\";\nmodule.exports = webpackEmptyAsyncContext;\n\n//# sourceURL=webpack://youtubeclone/./node_modules/@ffmpeg/ffmpeg/dist/esm/_lazy_namespace_object?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/dist/esm/const.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/dist/esm/const.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CORE_URL: () => (/* binding */ CORE_URL),\n/* harmony export */   CORE_VERSION: () => (/* binding */ CORE_VERSION),\n/* harmony export */   FFMessageType: () => (/* binding */ FFMessageType),\n/* harmony export */   MIME_TYPE_JAVASCRIPT: () => (/* binding */ MIME_TYPE_JAVASCRIPT),\n/* harmony export */   MIME_TYPE_WASM: () => (/* binding */ MIME_TYPE_WASM)\n/* harmony export */ });\nconst MIME_TYPE_JAVASCRIPT = \"text/javascript\";\nconst MIME_TYPE_WASM = \"application/wasm\";\nconst CORE_VERSION = \"0.12.9\";\nconst CORE_URL = `https://unpkg.com/@ffmpeg/core@${CORE_VERSION}/dist/umd/ffmpeg-core.js`;\nvar FFMessageType;\n(function (FFMessageType) {\n  FFMessageType[\"LOAD\"] = \"LOAD\";\n  FFMessageType[\"EXEC\"] = \"EXEC\";\n  FFMessageType[\"FFPROBE\"] = \"FFPROBE\";\n  FFMessageType[\"WRITE_FILE\"] = \"WRITE_FILE\";\n  FFMessageType[\"READ_FILE\"] = \"READ_FILE\";\n  FFMessageType[\"DELETE_FILE\"] = \"DELETE_FILE\";\n  FFMessageType[\"RENAME\"] = \"RENAME\";\n  FFMessageType[\"CREATE_DIR\"] = \"CREATE_DIR\";\n  FFMessageType[\"LIST_DIR\"] = \"LIST_DIR\";\n  FFMessageType[\"DELETE_DIR\"] = \"DELETE_DIR\";\n  FFMessageType[\"ERROR\"] = \"ERROR\";\n  FFMessageType[\"DOWNLOAD\"] = \"DOWNLOAD\";\n  FFMessageType[\"PROGRESS\"] = \"PROGRESS\";\n  FFMessageType[\"LOG\"] = \"LOG\";\n  FFMessageType[\"MOUNT\"] = \"MOUNT\";\n  FFMessageType[\"UNMOUNT\"] = \"UNMOUNT\";\n})(FFMessageType || (FFMessageType = {}));\n\n//# sourceURL=webpack://youtubeclone/./node_modules/@ffmpeg/ffmpeg/dist/esm/const.js?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/dist/esm/errors.js":
/*!********************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/dist/esm/errors.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ERROR_IMPORT_FAILURE: () => (/* binding */ ERROR_IMPORT_FAILURE),\n/* harmony export */   ERROR_NOT_LOADED: () => (/* binding */ ERROR_NOT_LOADED),\n/* harmony export */   ERROR_TERMINATED: () => (/* binding */ ERROR_TERMINATED),\n/* harmony export */   ERROR_UNKNOWN_MESSAGE_TYPE: () => (/* binding */ ERROR_UNKNOWN_MESSAGE_TYPE)\n/* harmony export */ });\nconst ERROR_UNKNOWN_MESSAGE_TYPE = new Error(\"unknown message type\");\nconst ERROR_NOT_LOADED = new Error(\"ffmpeg is not loaded, call `await ffmpeg.load()` first\");\nconst ERROR_TERMINATED = new Error(\"called FFmpeg.terminate()\");\nconst ERROR_IMPORT_FAILURE = new Error(\"failed to import ffmpeg-core.js\");\n\n//# sourceURL=webpack://youtubeclone/./node_modules/@ffmpeg/ffmpeg/dist/esm/errors.js?");

/***/ }),

/***/ "./node_modules/@ffmpeg/ffmpeg/dist/esm/worker.js":
/*!********************************************************!*\
  !*** ./node_modules/@ffmpeg/ffmpeg/dist/esm/worker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const.js */ \"./node_modules/@ffmpeg/ffmpeg/dist/esm/const.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/@ffmpeg/ffmpeg/dist/esm/errors.js\");\n/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n/// <reference lib=\"webworker\" />\n\n\nlet ffmpeg;\nconst load = async _ref => {\n  let {\n    coreURL: _coreURL,\n    wasmURL: _wasmURL,\n    workerURL: _workerURL\n  } = _ref;\n  const first = !ffmpeg;\n  try {\n    if (!_coreURL) _coreURL = _const_js__WEBPACK_IMPORTED_MODULE_0__.CORE_URL;\n    // when web worker type is `classic`.\n    importScripts(_coreURL);\n  } catch {\n    if (!_coreURL || _coreURL === _const_js__WEBPACK_IMPORTED_MODULE_0__.CORE_URL) _coreURL = _const_js__WEBPACK_IMPORTED_MODULE_0__.CORE_URL.replace('/umd/', '/esm/');\n    // when web worker type is `module`.\n    self.createFFmpegCore = (await __webpack_require__(\"./node_modules/@ffmpeg/ffmpeg/dist/esm lazy recursive\")(_coreURL)).default;\n    if (!self.createFFmpegCore) {\n      throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.ERROR_IMPORT_FAILURE;\n    }\n  }\n  const coreURL = _coreURL;\n  const wasmURL = _wasmURL ? _wasmURL : _coreURL.replace(/.js$/g, \".wasm\");\n  const workerURL = _workerURL ? _workerURL : _coreURL.replace(/.js$/g, \".worker.js\");\n  ffmpeg = await self.createFFmpegCore({\n    // Fix `Overload resolution failed.` when using multi-threaded ffmpeg-core.\n    // Encoded wasmURL and workerURL in the URL as a hack to fix locateFile issue.\n    mainScriptUrlOrBlob: `${coreURL}#${btoa(JSON.stringify({\n      wasmURL,\n      workerURL\n    }))}`\n  });\n  ffmpeg.setLogger(data => self.postMessage({\n    type: _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.LOG,\n    data\n  }));\n  ffmpeg.setProgress(data => self.postMessage({\n    type: _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.PROGRESS,\n    data\n  }));\n  return first;\n};\nconst exec = _ref2 => {\n  let {\n    args,\n    timeout = -1\n  } = _ref2;\n  ffmpeg.setTimeout(timeout);\n  ffmpeg.exec(...args);\n  const ret = ffmpeg.ret;\n  ffmpeg.reset();\n  return ret;\n};\nconst ffprobe = _ref3 => {\n  let {\n    args,\n    timeout = -1\n  } = _ref3;\n  ffmpeg.setTimeout(timeout);\n  ffmpeg.ffprobe(...args);\n  const ret = ffmpeg.ret;\n  ffmpeg.reset();\n  return ret;\n};\nconst writeFile = _ref4 => {\n  let {\n    path,\n    data\n  } = _ref4;\n  ffmpeg.FS.writeFile(path, data);\n  return true;\n};\nconst readFile = _ref5 => {\n  let {\n    path,\n    encoding\n  } = _ref5;\n  return ffmpeg.FS.readFile(path, {\n    encoding\n  });\n};\n// TODO: check if deletion works.\nconst deleteFile = _ref6 => {\n  let {\n    path\n  } = _ref6;\n  ffmpeg.FS.unlink(path);\n  return true;\n};\nconst rename = _ref7 => {\n  let {\n    oldPath,\n    newPath\n  } = _ref7;\n  ffmpeg.FS.rename(oldPath, newPath);\n  return true;\n};\n// TODO: check if creation works.\nconst createDir = _ref8 => {\n  let {\n    path\n  } = _ref8;\n  ffmpeg.FS.mkdir(path);\n  return true;\n};\nconst listDir = _ref9 => {\n  let {\n    path\n  } = _ref9;\n  const names = ffmpeg.FS.readdir(path);\n  const nodes = [];\n  for (const name of names) {\n    const stat = ffmpeg.FS.stat(`${path}/${name}`);\n    const isDir = ffmpeg.FS.isDir(stat.mode);\n    nodes.push({\n      name,\n      isDir\n    });\n  }\n  return nodes;\n};\n// TODO: check if deletion works.\nconst deleteDir = _ref10 => {\n  let {\n    path\n  } = _ref10;\n  ffmpeg.FS.rmdir(path);\n  return true;\n};\nconst mount = _ref11 => {\n  let {\n    fsType,\n    options,\n    mountPoint\n  } = _ref11;\n  const str = fsType;\n  const fs = ffmpeg.FS.filesystems[str];\n  if (!fs) return false;\n  ffmpeg.FS.mount(fs, options, mountPoint);\n  return true;\n};\nconst unmount = _ref12 => {\n  let {\n    mountPoint\n  } = _ref12;\n  ffmpeg.FS.unmount(mountPoint);\n  return true;\n};\nself.onmessage = async _ref13 => {\n  let {\n    data: {\n      id,\n      type,\n      data: _data\n    }\n  } = _ref13;\n  const trans = [];\n  let data;\n  try {\n    if (type !== _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.LOAD && !ffmpeg) throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.ERROR_NOT_LOADED; // eslint-disable-line\n    switch (type) {\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.LOAD:\n        data = await load(_data);\n        break;\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.EXEC:\n        data = exec(_data);\n        break;\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.FFPROBE:\n        data = ffprobe(_data);\n        break;\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.WRITE_FILE:\n        data = writeFile(_data);\n        break;\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.READ_FILE:\n        data = readFile(_data);\n        break;\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.DELETE_FILE:\n        data = deleteFile(_data);\n        break;\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.RENAME:\n        data = rename(_data);\n        break;\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.CREATE_DIR:\n        data = createDir(_data);\n        break;\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.LIST_DIR:\n        data = listDir(_data);\n        break;\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.DELETE_DIR:\n        data = deleteDir(_data);\n        break;\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.MOUNT:\n        data = mount(_data);\n        break;\n      case _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.UNMOUNT:\n        data = unmount(_data);\n        break;\n      default:\n        throw _errors_js__WEBPACK_IMPORTED_MODULE_1__.ERROR_UNKNOWN_MESSAGE_TYPE;\n    }\n  } catch (e) {\n    self.postMessage({\n      id,\n      type: _const_js__WEBPACK_IMPORTED_MODULE_0__.FFMessageType.ERROR,\n      data: e.toString()\n    });\n    return;\n  }\n  if (data instanceof Uint8Array) {\n    trans.push(data.buffer);\n  }\n  self.postMessage({\n    id,\n    type,\n    data\n  }, trans);\n};\n\n//# sourceURL=webpack://youtubeclone/./node_modules/@ffmpeg/ffmpeg/dist/esm/worker.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/@ffmpeg/ffmpeg/dist/esm/worker.js");
/******/ 	
/******/ })()
;